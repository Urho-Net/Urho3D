// WARNING - AUTOGENERATED - DO NOT EDIT
// 
// DynamicNavigationMesh.cs
// 
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using Urho.Urho2D;
using Urho.Gui;
using Urho.Resources;
using Urho.IO;
using Urho.Navigation;
using Urho.Network;
using File = Urho.IO.File;

namespace Urho.Navigation
{
	/// <summary>
	/// Constructor.
	/// </summary>
	public unsafe partial class DynamicNavigationMesh : NavigationMesh
	{
		unsafe partial void OnDynamicNavigationMeshCreated ();

		[Preserve]
		public DynamicNavigationMesh (IntPtr handle) : base (handle)
		{
			OnDynamicNavigationMeshCreated ();
		}

		[Preserve]
		protected DynamicNavigationMesh (UrhoObjectFlag emptyFlag) : base (emptyFlag)
		{
			OnDynamicNavigationMeshCreated ();
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int DynamicNavigationMesh_GetType (IntPtr handle);

		private StringHash UrhoGetType ()
		{
			Runtime.ValidateRefCounted (this);
			return new StringHash (DynamicNavigationMesh_GetType (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr DynamicNavigationMesh_GetTypeName (IntPtr handle);

		private string GetTypeName ()
		{
			Runtime.ValidateRefCounted (this);
			return Marshal.PtrToStringAnsi (DynamicNavigationMesh_GetTypeName (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int DynamicNavigationMesh_GetTypeStatic ();

		private static StringHash GetTypeStatic ()
		{
			Runtime.Validate (typeof(DynamicNavigationMesh));
			return new StringHash (DynamicNavigationMesh_GetTypeStatic ());
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr DynamicNavigationMesh_GetTypeNameStatic ();

		private static string GetTypeNameStatic ()
		{
			Runtime.Validate (typeof(DynamicNavigationMesh));
			return Marshal.PtrToStringAnsi (DynamicNavigationMesh_GetTypeNameStatic ());
		}

		[Preserve]
		public DynamicNavigationMesh () : this (Application.CurrentContext)
		{
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr DynamicNavigationMesh_DynamicNavigationMesh (IntPtr context);

		[Preserve]
		public DynamicNavigationMesh (Context context) : base (UrhoObjectFlag.Empty)
		{
			Runtime.Validate (typeof(DynamicNavigationMesh));
			handle = DynamicNavigationMesh_DynamicNavigationMesh ((object)context == null ? IntPtr.Zero : context.Handle);
			Runtime.RegisterObject (this);
			OnDynamicNavigationMeshCreated ();
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void DynamicNavigationMesh_RegisterObject (IntPtr context);

		/// <summary>
		/// Register with engine context.
		/// 
		/// </summary>
		public new static void RegisterObject (Context context)
		{
			Runtime.Validate (typeof(DynamicNavigationMesh));
			DynamicNavigationMesh_RegisterObject ((object)context == null ? IntPtr.Zero : context.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool DynamicNavigationMesh_Allocate (IntPtr handle, ref Urho.BoundingBox boundingBox, uint maxTiles);

		/// <summary>
		/// Allocate the navigation mesh without building any tiles. Bounding box is not padded. Return true if successful.
		/// </summary>
		public override bool Allocate (Urho.BoundingBox boundingBox, uint maxTiles)
		{
			Runtime.ValidateRefCounted (this);
			return DynamicNavigationMesh_Allocate (handle, ref boundingBox, maxTiles);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool DynamicNavigationMesh_Build (IntPtr handle);

		/// <summary>
		/// Build/rebuild the entire navigation mesh.
		/// </summary>
		public override bool Build ()
		{
			Runtime.ValidateRefCounted (this);
			return DynamicNavigationMesh_Build (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool DynamicNavigationMesh_Build0 (IntPtr handle, ref Urho.BoundingBox boundingBox);

		/// <summary>
		/// Build/rebuild a portion of the navigation mesh.
		/// </summary>
		public override bool Build (Urho.BoundingBox boundingBox)
		{
			Runtime.ValidateRefCounted (this);
			return DynamicNavigationMesh_Build0 (handle, ref boundingBox);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool DynamicNavigationMesh_Build1 (IntPtr handle, ref Urho.IntVector2 from, ref Urho.IntVector2 to);

		/// <summary>
		/// Rebuild part of the navigation mesh in the rectangular area. Return true if successful.
		/// </summary>
		public override bool Build (Urho.IntVector2 from, Urho.IntVector2 to)
		{
			Runtime.ValidateRefCounted (this);
			return DynamicNavigationMesh_Build1 (handle, ref from, ref to);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool DynamicNavigationMesh_IsObstacleInTile (IntPtr handle, IntPtr obstacle, ref Urho.IntVector2 tile);

		/// <summary>
		/// Return whether the Obstacle is touching the given tile.
		/// </summary>
		public bool IsObstacleInTile (Obstacle obstacle, Urho.IntVector2 tile)
		{
			Runtime.ValidateRefCounted (this);
			return DynamicNavigationMesh_IsObstacleInTile (handle, (object)obstacle == null ? IntPtr.Zero : obstacle.Handle, ref tile);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void DynamicNavigationMesh_RemoveTile (IntPtr handle, ref Urho.IntVector2 tile);

		/// <summary>
		/// Remove tile from navigation mesh.
		/// </summary>
		public override void RemoveTile (Urho.IntVector2 tile)
		{
			Runtime.ValidateRefCounted (this);
			DynamicNavigationMesh_RemoveTile (handle, ref tile);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void DynamicNavigationMesh_RemoveAllTiles (IntPtr handle);

		/// <summary>
		/// Remove all tiles from navigation mesh.
		/// </summary>
		public override void RemoveAllTiles ()
		{
			Runtime.ValidateRefCounted (this);
			DynamicNavigationMesh_RemoveAllTiles (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void DynamicNavigationMesh_DrawDebugGeometry (IntPtr handle, IntPtr debug, bool depthTest);

		/// <summary>
		/// Visualize the component as debug geometry.
		/// </summary>
		public override void DrawDebugGeometry (DebugRenderer debug, bool depthTest)
		{
			Runtime.ValidateRefCounted (this);
			DynamicNavigationMesh_DrawDebugGeometry (handle, (object)debug == null ? IntPtr.Zero : debug.Handle, depthTest);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void DynamicNavigationMesh_DrawDebugGeometry2 (IntPtr handle, bool depthTest);

		/// <summary>
		/// Add debug geometry to the debug renderer.
		/// </summary>
		public override void DrawDebugGeometry (bool depthTest)
		{
			Runtime.ValidateRefCounted (this);
			DynamicNavigationMesh_DrawDebugGeometry2 (handle, depthTest);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void DynamicNavigationMesh_SetMaxObstacles (IntPtr handle, uint maxObstacles);

		/// <summary>
		/// Set the maximum number of obstacles allowed.
		/// 
		/// </summary>
		private void SetMaxObstacles (uint maxObstacles)
		{
			Runtime.ValidateRefCounted (this);
			DynamicNavigationMesh_SetMaxObstacles (handle, maxObstacles);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void DynamicNavigationMesh_SetMaxLayers (IntPtr handle, uint maxLayers);

		/// <summary>
		/// Set the maximum number of layers that navigation construction can create.
		/// 
		/// </summary>
		private void SetMaxLayers (uint maxLayers)
		{
			Runtime.ValidateRefCounted (this);
			DynamicNavigationMesh_SetMaxLayers (handle, maxLayers);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint DynamicNavigationMesh_GetMaxObstacles (IntPtr handle);

		/// <summary>
		/// Return the maximum number of obstacles allowed.
		/// 
		/// </summary>
		private uint GetMaxObstacles ()
		{
			Runtime.ValidateRefCounted (this);
			return DynamicNavigationMesh_GetMaxObstacles (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint DynamicNavigationMesh_GetMaxLayers (IntPtr handle);

		/// <summary>
		/// Return the maximum number of layers permitted to build.
		/// 
		/// </summary>
		private uint GetMaxLayers ()
		{
			Runtime.ValidateRefCounted (this);
			return DynamicNavigationMesh_GetMaxLayers (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void DynamicNavigationMesh_SetDrawObstacles (IntPtr handle, bool enable);

		/// <summary>
		/// Draw debug geometry for Obstacles.
		/// 
		/// </summary>
		private void SetDrawObstacles (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			DynamicNavigationMesh_SetDrawObstacles (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool DynamicNavigationMesh_GetDrawObstacles (IntPtr handle);

		/// <summary>
		/// Return whether to draw Obstacles.
		/// 
		/// </summary>
		private bool GetDrawObstacles ()
		{
			Runtime.ValidateRefCounted (this);
			return DynamicNavigationMesh_GetDrawObstacles (handle);
		}

		public override StringHash Type {
			get {
				return UrhoGetType ();
			}
		}

		public override string TypeName {
			get {
				return GetTypeName ();
			}
		}

		[Preserve]
		public new static StringHash TypeStatic {
			get {
				return GetTypeStatic ();
			}
		}

		public new static string TypeNameStatic {
			get {
				return GetTypeNameStatic ();
			}
		}

		/// <summary>
		/// Return the maximum number of obstacles allowed.
		/// 
		/// Or
		/// Set the maximum number of obstacles allowed.
		/// 
		/// </summary>
		public uint MaxObstacles {
			get {
				return GetMaxObstacles ();
			}
			set {
				SetMaxObstacles (value);
			}
		}

		/// <summary>
		/// Return the maximum number of layers permitted to build.
		/// 
		/// Or
		/// Set the maximum number of layers that navigation construction can create.
		/// 
		/// </summary>
		public uint MaxLayers {
			get {
				return GetMaxLayers ();
			}
			set {
				SetMaxLayers (value);
			}
		}

		/// <summary>
		/// Return whether to draw Obstacles.
		/// 
		/// Or
		/// Draw debug geometry for Obstacles.
		/// 
		/// </summary>
		public bool DrawObstacles {
			get {
				return GetDrawObstacles ();
			}
			set {
				SetDrawObstacles (value);
			}
		}
	}
}
