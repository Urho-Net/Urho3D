// WARNING - AUTOGENERATED - DO NOT EDIT
// 
// VertexBuffer.cs
// 
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using Urho.Urho2D;
using Urho.Gui;
using Urho.Resources;
using Urho.IO;
using Urho.Navigation;
using Urho.Network;
using File = Urho.IO.File;

namespace Urho
{
	/// <summary>
	/// Hardware vertex buffer.
	/// </summary>
	public unsafe partial class VertexBuffer : UrhoObject, IGPUObject
	{
		unsafe partial void OnVertexBufferCreated ();

		[Preserve]
		public VertexBuffer (IntPtr handle) : base (handle)
		{
			OnVertexBufferCreated ();
		}

		[Preserve]
		protected VertexBuffer (UrhoObjectFlag emptyFlag) : base (emptyFlag)
		{
			OnVertexBufferCreated ();
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr VertexBuffer_CastToGPUObject (IntPtr handle);

		public GPUObject AsGPUObject ()
		{
			return new GPUObject (VertexBuffer_CastToGPUObject (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int VertexBuffer_GetType (IntPtr handle);

		private StringHash UrhoGetType ()
		{
			Runtime.ValidateRefCounted (this);
			return new StringHash (VertexBuffer_GetType (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr VertexBuffer_GetTypeName (IntPtr handle);

		private string GetTypeName ()
		{
			Runtime.ValidateRefCounted (this);
			return Marshal.PtrToStringAnsi (VertexBuffer_GetTypeName (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int VertexBuffer_GetTypeStatic ();

		private static StringHash GetTypeStatic ()
		{
			Runtime.Validate (typeof(VertexBuffer));
			return new StringHash (VertexBuffer_GetTypeStatic ());
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr VertexBuffer_GetTypeNameStatic ();

		private static string GetTypeNameStatic ()
		{
			Runtime.Validate (typeof(VertexBuffer));
			return Marshal.PtrToStringAnsi (VertexBuffer_GetTypeNameStatic ());
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr VertexBuffer_VertexBuffer (IntPtr context, bool forceHeadless);

		[Preserve]
		public VertexBuffer (Context context, bool forceHeadless = false) : base (UrhoObjectFlag.Empty)
		{
			Runtime.Validate (typeof(VertexBuffer));
			handle = VertexBuffer_VertexBuffer ((object)context == null ? IntPtr.Zero : context.Handle, forceHeadless);
			Runtime.RegisterObject (this);
			OnVertexBufferCreated ();
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void VertexBuffer_OnDeviceLost (IntPtr handle);

		/// <summary>
		/// Mark the buffer destroyed on graphics context destruction. May be a no-op depending on the API.
		/// </summary>
		public void OnDeviceLost ()
		{
			Runtime.ValidateRefCounted (this);
			VertexBuffer_OnDeviceLost (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void VertexBuffer_Release (IntPtr handle);

		/// <summary>
		/// Release buffer.
		/// </summary>
		public void Release ()
		{
			Runtime.ValidateRefCounted (this);
			VertexBuffer_Release (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void VertexBuffer_SetShadowed (IntPtr handle, bool enable);

		/// <summary>
		/// Enable shadowing in CPU memory. Shadowing is forced on if the graphics subsystem does not exist.
		/// 
		/// </summary>
		private void SetShadowed (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			VertexBuffer_SetShadowed (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool VertexBuffer_SetSize (IntPtr handle, uint vertexCount, uint elementMask, bool dynamic);

		/// <summary>
		/// Set size and vertex elements and dynamic mode using legacy element bitmask. Previous data will be lost.
		/// </summary>
		public bool SetSize (uint vertexCount, ElementMask elementMask, bool dynamic = false)
		{
			Runtime.ValidateRefCounted (this);
			return VertexBuffer_SetSize (handle, vertexCount, (uint)elementMask, dynamic);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool VertexBuffer_SetSize0 (IntPtr handle, uint vertexCount, VertexElement* elements, int size, bool dynamic);

		/// <summary>
		/// Set size, vertex elements and dynamic mode. Previous data will be lost.
		/// </summary>
		public bool SetSize (uint vertexCount, VertexElement* elements, int size, bool dynamic = false)
		{
			Runtime.ValidateRefCounted (this);
			return VertexBuffer_SetSize0 (handle, vertexCount, elements, size, dynamic);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool VertexBuffer_SetData (IntPtr handle, void* data);

		/// <summary>
		/// Set all data in the buffer.
		/// </summary>
		public bool SetData (void* data)
		{
			Runtime.ValidateRefCounted (this);
			return VertexBuffer_SetData (handle, data);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool VertexBuffer_SetDataRange (IntPtr handle, void* data, uint start, uint count, bool discard);

		/// <summary>
		/// Set a data range in the buffer. Optionally discard data outside the range.
		/// </summary>
		public bool SetDataRange (void* data, uint start, uint count, bool discard = false)
		{
			Runtime.ValidateRefCounted (this);
			return VertexBuffer_SetDataRange (handle, data, start, count, discard);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr VertexBuffer_Lock (IntPtr handle, uint start, uint count, bool discard);

		/// <summary>
		/// Lock the buffer for write-only editing. Return data pointer if successful. Optionally discard data outside the range.
		/// </summary>
		public IntPtr Lock (uint start, uint count, bool discard = false)
		{
			Runtime.ValidateRefCounted (this);
			return VertexBuffer_Lock (handle, start, count, discard);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void VertexBuffer_Unlock (IntPtr handle);

		/// <summary>
		/// Unlock the buffer and apply changes to the GPU buffer.
		/// </summary>
		public void Unlock ()
		{
			Runtime.ValidateRefCounted (this);
			VertexBuffer_Unlock (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool VertexBuffer_IsShadowed (IntPtr handle);

		/// <summary>
		/// Return whether CPU memory shadowing is enabled.
		/// 
		/// </summary>
		private bool IsShadowed ()
		{
			Runtime.ValidateRefCounted (this);
			return VertexBuffer_IsShadowed (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool VertexBuffer_IsDynamic (IntPtr handle);

		/// <summary>
		/// Return whether is dynamic.
		/// 
		/// </summary>
		private bool IsDynamic ()
		{
			Runtime.ValidateRefCounted (this);
			return VertexBuffer_IsDynamic (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool VertexBuffer_IsLocked (IntPtr handle);

		/// <summary>
		/// Return whether is currently locked.
		/// </summary>
		private bool IsLocked ()
		{
			Runtime.ValidateRefCounted (this);
			return VertexBuffer_IsLocked (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint VertexBuffer_GetVertexCount (IntPtr handle);

		/// <summary>
		/// Return number of vertices.
		/// 
		/// </summary>
		private uint GetVertexCount ()
		{
			Runtime.ValidateRefCounted (this);
			return VertexBuffer_GetVertexCount (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint VertexBuffer_GetVertexSize (IntPtr handle);

		/// <summary>
		/// Return vertex size in bytes.
		/// 
		/// </summary>
		private uint GetVertexSize ()
		{
			Runtime.ValidateRefCounted (this);
			return VertexBuffer_GetVertexSize (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern VertexElement* VertexBuffer_GetElement (IntPtr handle, VertexElementSemantic semantic, byte index);

		/// <summary>
		/// Return vertex element, or null if does not exist.
		/// </summary>
		public VertexElement* GetElement (VertexElementSemantic semantic, byte index = 0)
		{
			Runtime.ValidateRefCounted (this);
			return VertexBuffer_GetElement (handle, semantic, index);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern VertexElement* VertexBuffer_GetElement1 (IntPtr handle, VertexElementType type, VertexElementSemantic semantic, byte index);

		/// <summary>
		/// Return vertex element with specific type, or null if does not exist.
		/// </summary>
		public VertexElement* GetElement (VertexElementType type, VertexElementSemantic semantic, byte index = 0)
		{
			Runtime.ValidateRefCounted (this);
			return VertexBuffer_GetElement1 (handle, type, semantic, index);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool VertexBuffer_HasElement (IntPtr handle, VertexElementSemantic semantic, byte index);

		/// <summary>
		/// Return whether has a specified element semantic.
		/// </summary>
		public bool HasElement (VertexElementSemantic semantic, byte index = 0)
		{
			Runtime.ValidateRefCounted (this);
			return VertexBuffer_HasElement (handle, semantic, index);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool VertexBuffer_HasElement2 (IntPtr handle, VertexElementType type, VertexElementSemantic semantic, byte index);

		/// <summary>
		/// Return whether has an element semantic with specific type.
		/// </summary>
		public bool HasElement (VertexElementType type, VertexElementSemantic semantic, byte index = 0)
		{
			Runtime.ValidateRefCounted (this);
			return VertexBuffer_HasElement2 (handle, type, semantic, index);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint VertexBuffer_GetElementOffset (IntPtr handle, VertexElementSemantic semantic, byte index);

		/// <summary>
		/// Return offset of a element within vertex, or M_MAX_UNSIGNED if does not exist.
		/// </summary>
		public uint GetElementOffset (VertexElementSemantic semantic, byte index = 0)
		{
			Runtime.ValidateRefCounted (this);
			return VertexBuffer_GetElementOffset (handle, semantic, index);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint VertexBuffer_GetElementOffset3 (IntPtr handle, VertexElementType type, VertexElementSemantic semantic, byte index);

		/// <summary>
		/// Return offset of a element with specific type within vertex, or M_MAX_UNSIGNED if element does not exist.
		/// </summary>
		public uint GetElementOffset (VertexElementType type, VertexElementSemantic semantic, byte index = 0)
		{
			Runtime.ValidateRefCounted (this);
			return VertexBuffer_GetElementOffset3 (handle, type, semantic, index);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern byte* VertexBuffer_GetShadowData (IntPtr handle);

		/// <summary>
		/// Return CPU memory shadow data.
		/// </summary>
		private byte* GetShadowData ()
		{
			Runtime.ValidateRefCounted (this);
			return VertexBuffer_GetShadowData (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern ulong VertexBuffer_GetBufferHash (IntPtr handle, uint streamIndex);

		/// <summary>
		/// Return buffer hash for building vertex declarations. Used internally.
		/// </summary>
		public ulong GetBufferHash (uint streamIndex)
		{
			Runtime.ValidateRefCounted (this);
			return VertexBuffer_GetBufferHash (handle, streamIndex);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint VertexBuffer_GetVertexSize4 (uint elementMask);

		/// <summary>
		/// Return vertex size for a legacy vertex element bitmask.
		/// </summary>
		public static uint GetVertexSize (ElementMask elementMask)
		{
			Runtime.Validate (typeof(VertexBuffer));
			return VertexBuffer_GetVertexSize4 ((uint)elementMask);
		}

		public override StringHash Type {
			get {
				return UrhoGetType ();
			}
		}

		public override string TypeName {
			get {
				return GetTypeName ();
			}
		}

		[Preserve]
		public static StringHash TypeStatic {
			get {
				return GetTypeStatic ();
			}
		}

		public static string TypeNameStatic {
			get {
				return GetTypeNameStatic ();
			}
		}

		/// <summary>
		/// Return whether CPU memory shadowing is enabled.
		/// 
		/// Or
		/// Enable shadowing in CPU memory. Shadowing is forced on if the graphics subsystem does not exist.
		/// 
		/// </summary>
		public bool Shadowed {
			get {
				return IsShadowed ();
			}
			set {
				SetShadowed (value);
			}
		}

		/// <summary>
		/// Return whether is dynamic.
		/// 
		/// </summary>
		public bool Dynamic {
			get {
				return IsDynamic ();
			}
		}

		/// <summary>
		/// Return whether is currently locked.
		/// </summary>
		public bool Locked {
			get {
				return IsLocked ();
			}
		}

		/// <summary>
		/// Return number of vertices.
		/// 
		/// </summary>
		public uint VertexCount {
			get {
				return GetVertexCount ();
			}
		}

		/// <summary>
		/// Return vertex size in bytes.
		/// 
		/// </summary>
		public uint VertexSize {
			get {
				return GetVertexSize ();
			}
		}

		/// <summary>
		/// Return CPU memory shadow data.
		/// </summary>
		public byte* ShadowData {
			get {
				return GetShadowData ();
			}
		}
	}
}
